---
layout: post
title: 逆向
date: 2025-11-12
tags:
  - Tools
  - Unity2D
---

# 逆向

引路人

[unity引擎基于Windows下的il2cpp逆向初探——以CTF赛题为例-先知社区](https://xz.aliyun.com/news/15811)

[[原创\]IL2CPP 逆向初探-软件逆向-看雪安全社区｜专业技术交流与安全研究论坛](https://bbs.kanxue.com/thread-278275-1.htm)

## dnspy

反编译C#相关程序，反编译修改后需要保存模块以应用到目标程序。



## IDA激活

需要自行配备python3.8以上环境，IDA安装时会自动检测。

磁力链接下载IDA9.1

```
magnet:?xt=urn:btih:f24cfadb8a66b343bf1ff4f0c1386a5f6991c818&dn=ida91
```

激活方式，生成License

[ThatNotEasy/IDA-Patcher: IDA Pro Patcher & License Generator](https://github.com/ThatNotEasy/IDA-Patcher)

main第28行写错了，修改为

```python
end_year = args.end_date or (now.year + 10)
```

执行命令参数为安装目录，也就是ida.exe的根目录

```python
python main.py -p "D:\Tools\IDA"
```

成功激活后如下

![image-20251111230515010](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511112305090.png)

## Zygisk-Il2CppDumper

下载Magisk工具[Release Magisk (f9f02c65) (30403) · ayasa520/Magisk](https://github.com/ayasa520/Magisk/releases/tag/canary-30403)

【安卓模拟器安装 Magisk30.4】 https://www.bilibili.com/video/BV1PYWHzCEjE/?share_source=copy_web&vd_source=05320767bb904def1ce7c1e88823462a

获取游戏包名称，以mumu模拟器为例，在这个路径的文件夹名称就是包名。

![image-20251112114512032](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511121145115.png)

Fork本体[violet-wdream/Zygisk-Il2CppDumper: Using Zygisk to dump il2cpp data at runtime](https://github.com/violet-wdream/Zygisk-Il2CppDumper)，不需要下载，然后在你Fork的分支actions里面输入包名，构建文件。

原仓库使用的actions太久了需要改成v4版本，修改了build.yml

```yml
- uses: actions/upload-artifact@v4
```



![image-20251112114757145](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511121147244.png)

[Workflow runs · violet-wdream/Zygisk-Il2CppDumper](https://github.com/violet-wdream/Zygisk-Il2CppDumper/actions)放置少女`jp.glee.girl`构建结果模块

安装构建的模块。

![image-20251112115650744](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511121156812.png)

启动游戏，会在`/data/data/GamePackageName/files/`目录下生成`dump.cs`

这里使用mumu模拟器自带的root explorer查看。选中后选择压缩就会发送到可直接查看的目录`/storage/emulated/0/SpeedSoftware/Archives`

![image-20251112115318123](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511121153187.png)

本机的根目录。

![image-20251112115512893](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511121155955.png)

## Il2CppDumper

和Zygisk-Il2CppDumper二选一即可。[Perfare/Il2CppDumper: Unity il2cpp reverse engineer](https://github.com/Perfare/Il2CppDumper/tree/master)

使用方法[Il2CppDumper/README.zh-CN.md at master · Perfare/Il2CppDumper](https://github.com/Perfare/Il2CppDumper/blob/master/README.zh-CN.md)

这里的放置少女的global-metadata.dat已被加密，所以不适用。

对于global-metadata.dat和libil2cpp.so都正常的情况：会生成以下这些文件

![image-20260114214423024](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202601142144096.png)

如果你没有指定目录，那么就会这些生成在Il2CppDumper安装目录

在IDA中选择`file > script file...` 选中Il2CppDumper安装目录下的`ida_with_struct_py3.py`

然后会继续弹框让你选择文件，依次选择`script.json` > `il2cpp.h` 

之后就等待IDA运行脚本了。



## ADB

```bash
adb connect 127.0.0.1:5555
adb connect 127.0.0.1:16384
adb devices
adb root
adb shell
exit
#查找package，不建议自己查，不如MT管理器简单方便
pm path com.fknzj.qooapp
ls -l /data/data/com.fknzj.qooapp
```





## Frida连接

### 模拟器frida服务

[APP逆向第五课： Frida安装&基础HOOK⽅法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fWupzqEzq/?spm_id_from=333.337.search-card.all.click&vd_source=cc62639f8cba7649c1be3fdeff181bb1)

[MuMu模拟器开发者须知_MuMu模拟器_安卓模拟器](https://mumu.163.com/help/20240807/40912_1086360.html)

模拟器adb shell连接

查看模拟器adb端口

![image-20251113135216351](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131352397.png)

找到adb路径`D:\Games\Mumu\MuMuPlayer\nx_device\12.0\shell`，getprop查询CPU架构为`x86_64`

```bash
adb.exe connect 127.0.0.1:5555
adb.exe shell
getprop ro.product.cpu.abi
```

![image-20251113135346077](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131353104.png)

找到对应版本下载。https://github.com/frida/frida/releases/download/16.1.0/frida-server-16.1.0-android-x86_64.xz

解压xz文件后得到一个无拓展名文件。重新命名为`frida` 根据个人喜好。

传入到模拟器中。这里使用mumu共享文件夹传输文件，然后在共享文件夹再次把文件移动到本机根目录

或者使用push指令一步到位

```bash
adb push ...\frida /data/local/tmp 
```

![image-20251113142748911](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131427988.png)

打开root exploreer或者任意root管理器，找到frida文件

![image-20251113142910547](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131429592.png)

再次移动frida，移动到tmp目录，因为其他目录下不能修改这个文件的权限。

![image-20251113143136570](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131431618.png)

修改文件权限为777，全部勾选即可。

![image-20251113143206934](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131432986.png)

接下来cd进这个目录，启动frida

```bash
cd /data/local/tmp;
./frida
```

然后这里会显示权限不够。

```bash
`Cetus:/data/local/tmp $ ./frida
Unable to save SELinux policy to the kernel: Permission denied`。
```

需要提升权限，输入exit返回

```bash
exit
adb root
adb shell
cd /data/local/tmp
./frida
```

然后如果命令行一动不动，说明模拟器frida服务成功开启了

![image-20251113145652991](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131456040.png)

### 物理机连接frida服务

接下来用物理机连接模拟器的frida服务，新建一个终端，还是在`D:\Games\Mumu\MuMuPlayer\nx_device\12.0\shell`这个路径下，进行端口转发。

```bash
adb forward tcp:27042 tcp:27042 
```

物理机下载`frida`和`frida-tools`，参照这个表找到对应版本[thelicato/frida-compatibility-matrix: Compatible versions of the frida package for each version of the frida-tools package. Automatically updated through CI/CD](https://github.com/thelicato/frida-compatibility-matrix)

因为我们下载的是`16.1.0`版本，所以tools下载`12.3.0`，如果版本下载太高了就无法识别模拟器的frida服务。

```bash
pip uninstall frida-tools frida -y #如果下载错了需要先卸载frida和依赖
pip install frida==16.1.0 frida-tools==12.3.0
```

两个包都需要指定版本，不然会自动下载默认版本，可能会出问题。

如果一切顺利，查询模拟器进程，可以查到PID和对应进程。

```bash
frida-ps -U
```

![image-20251113153704169](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131537209.png)

### hook

模拟器frida服务容易掉线，如果出现了问题可以检查一下是不是frida服务掉线了。

最后一个参数是包名，[获取方式在Zygisk-Il2CppDumper这个章节](#Zygisk-Il2CppDumper)，这里是目标游戏放置少女的包名。

在物理机下输入以下指令，会自动启动

```bash
frida -U -f "jp.glee.girl"
```

![image-20251113154533916](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131545008.png)

这里就完成了Frida功能的初步验证。

## 获取逆向所需文件

打开APK安装包，自己找，只要是unity游戏一定会有。

- [ ] libil2cpp.so 所有的C#方法被编译成了C++
- [ ] global-metadata.dat 结构化的数据库，存放了定义

![image-20251113122418971](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131224016.png)

![image-20251113122521846](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131225892.png)

启动游戏后，通过Zygisk-Il2CppDumper可以自动获取dump.cs，可以绕过保护。

- [ ] dump.cs  反编译出的所有方法的可读函数名



## 获取关键加密信息

使用IDA导入文件`libil2cpp.so`

从dump.cs中寻找关键字`decrypt` `encrypt`

![image-20251113120535063](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131205246.png)

可以看到这里有对称加密算法的相关方法。

然后可以去IDA按g输入跳转RVA地址，观察是否有值得注意的信息，可以右键切换视图。

继续搜索相关的信息`RC4 DES AES`等等

基本可以确定加密算法是 RC4，需要获取初始向量IV和密钥Key

Gemini编写hook脚本` hook.js`

关闭游戏，通过frida注入hook启动，需要在hook脚本路径下执行，或者指定hook路径。

这个是动态注入的，也就是说你可以随时更改hook脚本来观察结果。

以下两种方式选择一种，在物理机上执行。

Spawn启动（会重启游戏，如果游戏是开着的）

```js
frida -U -f "jp.glee.girl" -l hook.js 
Process.enumerateModules()
```

Attach到进程启动，注意每次重开游戏PID都会改变，需要重新在物理机上查询。

```js
frida-ps -U #查看PID为 28902
frida -H 127.0.0.1:27042 -p 28902 -l hook.js --realm emulated 
#如果报错提示Failed to attach: process is not using emulation则移除 --realm emulated
Process.enumerateModules()
```

==需要注意的是mumu模拟器当前如果是x86-64架构，而游戏是arm64架构，是无法直接找到`libil2cpp.so`模块的，而是通过`libhoudini.so`翻译层执行。==

[网易mumu、雷电模拟器，修改游戏运行架构 - 知乎](https://zhuanlan.zhihu.com/p/540151136)

反斜杠表示转义。

![image-20251113193254212](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511131932285.png)

卸载游戏，重启模拟器。试了一下，改成这样直接APK无法下载了。

另一个解法就是换成root过的真机。



hook脚本也确实提示找不到libil2cpp.so，这里在adb shell上查看一下进程内存分配，PID替换为实际进程号

```js
cat /proc/PID/maps
```

发现有`global-metadata.dat`，可以确认`libil2cpp.so` 模块一定在内存中

```js
78d540735000-78d540dfa000 rw-p 00000000 08:23 6423855                    /data/media/0/Android/data/jp.glee.girl/files/il2cpp/Metadata/global-metadata.dat
```

但是却找不到，说明大概率是模块名称被修改了。

未完待续。。。





## FakeHeader

**FakeHeader**（伪头）是Unity资源文件的一种保护机制，通过在文件头部添加虚假的数据结构来干扰解包工具。

1. **前置填充**: 文件开头有大量00或FF填充
2. **多重签名**: 包含多个UnityFS签名
3. **大小错位**: 实际文件大小与头中记录不符
4. **加密数据**: 文件头包含非标准加密数据
5. **自定义结构**: 游戏自定义的保护结构

![image-20251031233624014](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202510312336183.png)

1. **多个Unity版本字符串**：
   - `2021.3.8f1`
   - `2021.3.29f1`
   - 重复出现多次
2. **UnityFS签名位置异常**：
   - 真正的UnityFS签名不在文件开头
   - 前面有大量版本字符串和其他数据



## UnityCN

搜索

```c
加密：AssetBundle.SetAssetBundleEncryptKey();
解密：AssetBundle.SetAssetBundleDecryptKey();
```



![image-20260129193440305](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202601291934473.png)

![image-20260129195036875](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202601291950066.png)

![image-20260129214644106](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202601292146207.png)

使用UTF8编码[UTF-8编码转换器-ME2在线工具](https://www.metools.info/code/utf8235.html)  `ResonanceRebornR`

得到`5265736F6E616E63655265626F726E52`

```c
R	0x52
e	0x65
s	0x73
o	0x6F
n	0x6E
a	0x61
n	0x6E
c	0x63
e	0x65
R	0x52
e	0x65
b	0x62
o	0x6F
r	0x72
n	0x6E
R	0x52
```

![image-20260129184109816](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202601291841994.png)



## `AES`加密

```python
import os
import sys
import concurrent.futures
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import multiprocessing

def text_to_hex(text, length_bytes):
    """将文本转换为指定长度的十六进制字符串"""
    bytes_data = text.encode('utf-8')
    hex_data = bytes_data.hex()
    
    # 截断或填充到指定长度
    target_length = length_bytes * 2  # 每字节对应2个十六进制字符
    if len(hex_data) > target_length:
        hex_data = hex_data[:target_length]
    else:
        hex_data = hex_data.ljust(target_length, '0')
    
    return hex_data

def decrypt_file(file_path, key, iv):
    try:
        with open(file_path, 'rb') as f:
            ciphertext = f.read()
        
        cipher = AES.new(key, AES.MODE_CBC, iv)
        decrypted_data = unpad(cipher.decrypt(ciphertext), AES.block_size)
        
        output_path = os.path.splitext(file_path)[0]
        with open(output_path, 'wb') as f:
            f.write(decrypted_data)
        
        return f"已解密: {file_path} -> {output_path}"
    except Exception as e:
        return f"解密失败 {file_path}: {str(e)}"

def traverse_directory(directory, key, iv):
    files_to_process = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            files_to_process.append(os.path.join(root, file))
    
    # 获取CPU核心数，设置线程池大小
    cpu_count = multiprocessing.cpu_count()
    thread_count = max(1, cpu_count)  # 至少1个线程
    
    print(f"使用 {thread_count} 个线程进行解密")
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=thread_count) as executor:
        # 提交所有文件解密任务
        future_to_file = {executor.submit(decrypt_file, file_path, key, iv): file_path for file_path in files_to_process}
        
        # 收集并打印结果
        for future in concurrent.futures.as_completed(future_to_file):
            result = future.result()
            print(result)

def main():
    while True:
        # 获取文件或目录路径
        path = input("请输入文件或文件夹路径(输入q退出): ").strip()
        if path.lower() == 'q':
            break
        if not os.path.exists(path):
            print("路径不存在，请检查后重试。")
            continue
        
        # 获取密钥和IV
        key_input = input("请输入16/24/32字节密钥(十六进制或普通文本): ").strip()
        iv_input = input("请输入16字节IV(十六进制或普通文本): ").strip()
        
        # 自动转换非十六进制输入
        try:
            key = bytes.fromhex(key_input)
        except ValueError:
            key_length = 32  # 默认16字节密钥
            if len(key_input) >= 24:
                key_length = 48  # 24字节密钥
            if len(key_input) >= 32:
                key_length = 64  # 32字节密钥
            key_hex = text_to_hex(key_input, key_length // 2)
            key = bytes.fromhex(key_hex)
            print(f"已将密钥转换为十六进制: {key_hex[:16]}...")
        
        try:
            iv = bytes.fromhex(iv_input)
        except ValueError:
            iv_hex = text_to_hex(iv_input, 16)
            iv = bytes.fromhex(iv_hex)
            print(f"已将IV转换为十六进制: {iv_hex}")
        
        # 验证密钥和IV长度
        if len(key) not in [16, 24, 32]:
            print("密钥长度必须是16、24或32字节。")
            continue
        if len(iv) != 16:
            print("IV长度必须是16字节。")
            continue
        
        # 处理文件或目录
        if os.path.isfile(path):
            print(decrypt_file(path, key, iv))
        else:
            traverse_directory(path, key, iv)
        
        # 询问是否继续
        while True:
            choice = input("是否继续? (y/n): ").strip().lower()
            if choice == 'y':
                break
            elif choice == 'n':
                return
            else:
                print("无效的选择，请输入y或n")

if __name__ == "__main__":
    try:
        from Crypto.Cipher import AES
    except ImportError:
        print("缺少pycryptodome库，请先安装: pip install pycryptodome")
        sys.exit(1)
    
    main()
```

还没用过。。



## Spine合并

[Spine文件怎么把文件和背景合二为一 - 讨论 - Live2DHub](https://live2dhub.com/t/topic/2780/19)

![image](https://live2dhub.com/uploads/default/original/2X/6/6cb8b210d05a99514ef2bd8b86badd46ae666287.png)



## AseetStudio Fork开发

### 环境设置

IDE为Rider

使用`.NET8.0` 开发

`MSbuild` 选择IDE自带的17.0版本。

![image-20251106203527957](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511062035072.png)

配置选择GUI，设置为`.NET8.0` 后启动。

![image-20251106203928618](https://cdn.jsdelivr.net/gh/violet-wdream/Drawio/PNG/202511062039727.png)

### 项目架构
